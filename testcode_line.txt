TEST 
case 1: run app, click f9 -> hide [pass]
case 2: run app, click f9 -> hide, click again -> pop + focus text [pass]
case 3: run app first time, hide, focus other app, click f9 -> pop up + focus text [pass]
case 4: when other app has focus, pomo still in text, f9 -> pop, f9 -> hide, return focus to app [pass]
case 5: when open text has focus, click on chrome, then the pomo will be hide under chrome -> then click f9, hope raise to top but orange nhap nhay [fail]





2021/08/21:
- this is possible, when put the on_press in the tk class
class App(tkinter.Tk):
    """In this class will have the keyboard listener"""
    def __init__(self):
        super().__init__()
        self.keyboard_listener = keyboard.Listener(
                                        on_press=self.on_press,
                                        on_release=self.on_release)
        self.keyboard_listener.start()
        self.data = 5

    
    def on_press(self, key):
        try:
            print('alphanumeric key {0} pressed'.format(
                key.char))
            if key == KeyCode.from_char('['):
                pass
        except AttributeError:
            print('special key {0} pressed'.format(
                key))

==========================
- when make code like this
def on_press(self, key):
        try:
            print('alphanumeric key {0} pressed'.format(
                key.char))
            if key == KeyCode.from_char('['):
                self.minimize_window()
            if key == KeyCode.from_char(']'):
                self.maximize_window()
        except AttributeError:
            print('special key {0} pressed'.format(
                key))

def minimize_window(self):
        """Make window -> icon in taskbar"""
        self.iconify()

!!: then when make lost focus to chrome and then press ']' -> the window is orange and try to take the focus but can't, now want to check the focus 

!!: a very very amazing behaviour
- first add the line print(self.focus_get())
- when the tk window have focus -> will print '.', dot means that is the root window, ok
- then if make it lost focus, it will print 'None'
- if make it icon, then get focus to chrome then press ']' (to deiconify) then the icon in task bar will orange and nhap nhay, but it cannot pop up. HOWEVER, if I click the '[' to iconify and the press to deiconify again, it will immediately popup and get focus, how amazing. Note that even when the orange icon nhap nhay, the tk window GET focus, it return '.' BUT it CANNOT popup. So in reality, I just need to simulate the pressing button to get the effect, cool

!!: about the state of window
- even when nhap nhay orange, the state is NORMAL and it already has the focus. Now how to know it is not popup????

!!: about the name of current has focus window
- when nhap nhay orange, the name of current focus window is google chrome, cool, so I can use this to alter the behaviour 
- if use mouse to click the minimize button in the window, the name of focus window automatically switch to the google chrome 
- after iconify -> the name is still 'tk' 



=====================================
#KeyCode.from_char('[') and ALT_L_PRESSED:

#app.after(1, lambda: app.focus_force())

#app.focus_set()

# else:
        #     # app.wm_state('iconic')
        #     # app.wm_state('normal')
        #     # root.attributes('-topmost', True)
        #     # app.focus_force()       
        #     # app.cmd_text_get_focus()
        #     # root.focus_force() #must type 2 times -> focus force
        #     app.show_window()
        #     app.cmd_text_get_focus()

# if key == Key.esc:
    #     # Stop listener
    #     return False

# if key == KeyCode.from_char('[')
# to check if the key is pressed is '['

# self.attributes('-topmost', True)
        # self.focus_force()
        # self.wm_state('iconic')

def on_release(key):  
    global ALT_L_PRESSED
    print('{0} release'.format(
        key))
    if key == Key.alt_l:
        ALT_L_PRESSED = False
    # if key == Key.esc:
    #     # Stop listener
    #     return False

=======
self.state()
==> return 'icon', 'normal'

===========
GetWindowText(GetForegroundWindow()) => return the name of current window have focus

=============
handle = win32gui.FindWindow(0, self.prev_app_has_focus)   
win32gui.SetForegroundWindow(handle)

============
# added_time = datetime.timedelta(minutes=notify_in_min)
# notify_time = now + added_time
# while now < notify_time:
#     time.sleep(1)
#     now = datetime.datetime.now()